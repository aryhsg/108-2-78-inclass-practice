---
title: '410779095'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{install.packages(c("googlesheets4","tidyverse"))}
```

```{a =2}
```

b =3
```{r}
a=2
b=3

```
```{r}
`幹`=78 # 特殊字詞可用頓點包起來


```
# ```{r}
`我的年紀`= 19
`我的年紀`->my_age
```
```{r}
# vNum1 <- c(-1,5)
# vNum2 <- c(2,3)
# vNum3 <- c(vNum1,vNum2)
# vNum4 <- c(-1,5,2,3)
# vNum5 <- c(c(-1,5),c(2,3))
```
```{r}
vNum1 <- c(-1,5) 
vNum2 <- c(2,3)
vNum4 <- c() # 空向量
```
```{r}
vNum3 <- c(vNum2, vNum1)
vNum4 <- c(vNum4, vNum1) # 向量疊代 （recursive vector concatenate）會一直疊上去
```
```{r}
library(googlesheets4)
`出席狀況表單網址` <-   # 缺乏定義值
ss <- as_sheets_id(`出席狀況表單網址`)
homework_sheet <- sheets_read(ss,sheet=1)
```


```{r}
num1<-5 # 非整數
num2<-5L # 整數

num1Vector<-c(5,6,7)
num2Vector<-c(5L,6L,7L)
class(num)
class(int)
class(char)
class(logi)
```

```{r}

browseURL("https://docs.google.com/spreadsheets/d/1EAG49qDKPWWi0ebkVr29TLrvVnoBPfkvxYY-J3xLAHY/edit#gid=458686645")
```
```{r}
library(lubridate)
```


```{r}
`我的年紀`<- 20
my_age-> `我的年紀`
```
a <- 15 # 變數設定
b <- a # 呼叫a的值，用來設定變數b的值，相當於 b <- 15
```{r}
number= 20
class(number)
typeof(number)
```

```{r}
# 10位學生的主系
majors10_char <- c('經濟學系','社會學系','社會學系','經濟學系','經濟學系','社會學系','經濟學系','經濟學系','經濟學系','社會學系')

typeof(majors10_char)
class(majors10_char)
```
majors10_factor <- factor(majors10_char)
# 或
majors10_factor <- factor(
  c('經濟學系','社會學系','社會學系','經濟學系','經濟學系','社會學系','經濟學系','經濟學系','經濟學系','社會學系')
)

typeof(majors10_factor)
class(majors10_factor)

majors10_char
majors10_factor



```{r}
listeample <- li
```{r}
 # 用vector儲存
c("2020/03/21T13:40:55Z","一方","2","水果茶")
 # 用list儲存
library(lubridate)
list("2020/03/21T13:40:55Z","一方","2",'水果茶') #date/time #charater #numertic #charater
```
```{r}
library(lubridate)
`小明交易1` <- list(
  ymd_hms("2020-03-31T13:40:55Z"), # Date/Time class
  "一芳", # character
  2, # numeric
  "水果茶" # character
)
print(`小明交易1`)
```

```{r}
# list含兩個vectors
`小明108學年課表A` <- list(
  c("108-1","高級會計學","高等統計學"),
  c("108-2","食在拉丁美洲")
)
print(`小明108學年課表A`)
```

```{r}
# list含兩個lists
'小明108學年課表B' <- list(
  list("108-1","高級會計學","高等統計學"),
  list("108-2","食在拉丁美洲")
)

print('小明108學年課表B')
```

```{r}
# list含兩個lists, 子層list又各含兩個vectors
'小明108學年課表C' <- list(list(c("108-1"), c("高級會計學","高等統計學")# 可只寫 "108-1
       ),
  list(
    c("108-2"),
    c("食在拉丁美洲")
  )
)
print('小明108學年課表C')
```

```{r}
# list含兩個lists, 子層list又各含兩個vectors
"小明108學年課表D" <- list(
  '108學年第1學期'=list(
    semester=c("108-1"), # 可只寫 "108-1"
    course=c("高級會計學","高等統計學")
       ),
  '108學年第2學期'=list(
    semester=c("108-2"),
    course=c("食在拉丁美洲")
  )
)
print("小明108學年課表D")
```

```{r}

commit <- list (
  list(name='Martin老師',
       email='mtlin@gm.ntpu.edu.tw',
       datetime=ymd_hms('2020-03-25T07:17:40Z'))
list(name='emilyluckey',
     email='emily007@gmail.com',
     datetime=ymd_hms('2020-03-26T08:18:40Z')))
  
```

```{r}
'小明'=list(
course1 = list(name='alice',course=c('個體經濟學'),score=c(85),name='mark',course=c('總體經濟學'),score=c(73)),
course2 = list(name='jason',course=c('作業研究'),score=c(90))
)
  

```


```{r}
'天氣預報' <-list(
  '台北市' = list(
    date = c(
      today = "2020-03-31", 
      tomorrow = "2020-04-01"
    ), 
    highest = 25, 
    lowest = 18
  ), 
  '新北市' = list(
    date = c(
      today = "2020-03-31", 
      tomorrow = "2020-04-01"
    ), 
    higest = 24, 
    lowest = 15
  )
)
print('天氣預報')
```
```{r}
list(
  '20200331' =list(
  '台北市',high=25,low=18,'新北市',high=24,low=15
  ),
  '20200401' =list(
  '台北市',high=25,low=18,'新北市',high=24,low=15
  )
)


```

```{r}
vectorExample <- c("小明","小英","大雄")

# 有多少位置可選：
length(vectorExample)
```
```{r}
vectorExample[[1]]
vectorExample[[3]]
#選取特定位置
```
```{r}
listExample <- 
  list(
    student="小明",
    `學期`=list(
      `108-1`=list(
        list(
          name="個體經濟學",
          teacher="Alice",
          grade=85
        )
      ),
      `108-2`=list(
        list(
          name="總體經濟學",
          teacher="Mark",
          grade=78
        )
      )
    )
  )
# 有多少位置可選：
length(listExample)

```
```{r}
listExample[[1]]
listExample[[2]]
```
```{r}
library(jsonlite)
fromJSON("https://data.tainan.gov.tw/dataset/4cd9345a-04bf-4328-a97d-314ff78b4763/resource/afc025fc-1ef4-447c-b785-a680391d0ca1/download/tnsport2.json", simplifyDataFrame = F) -> tainanSportsMap
```
```{r}
tainanSportsMap[[1]]
tainanSportsMap[[230]]

```
```{r}
# 有多少名字可選：
names(listExample)
```
```{r}
listExample$student
listExample$`學期` # 特殊命名依然要用反頓點呼叫
```

```{r}
str(listExample$學期)
```

```{r}
listExample[["student"]] #兩種方法叫出特定位置
listExample$student

listExample[["學期"]] # 小心不是反頓點喔。
listExample$`學期`
```
```{r}
fromJSON("http://data.ntpc.gov.tw/api/v1/rest/datastore/382000000A-000157-002",
         simplifyDataFrame = F) -> newTaipeiCityVaccine
```
```{r}
length(newTaipeiCityVaccine)
str(newTaipeiCityVaccine$success)                 #三種叫出特定位置的方法
str(newTaipeiCityVaccine[[1]])
str(newTaipeiCityVaccine[["success"]])
```
```{r}
vectorExample
vectorExample[c(1,3)]
vectorExample[c(3,2,1)] # 產生重新排列效果
```
```{r}
# 顯示到第一層
str(listExample, max.level=1)

listExample[c("學期")]
listExample[c("student","學期")]
```

```{r}
fromJSON("https://www.dropbox.com/s/qnm9bnz7vccrvcz/taipeiNightMarkets.json?dl=1", simplifyDataFrame = F) -> taipeiNightMarkets
```
```{r}
taipeiNightMarkets[c(1,2,3)]
```

```{R}
str(taipeiNightMarkets,max.level = 1)
taipeiNightMarkets[c(T,F,F,F,T,F,F,F,F,T,F,F,F,T)]
```
```{r}
str(listExample)

```
```{r}
get1<- listExample[["學期"]]
str(get1)
get1 # 學期拿出來，有3個元素的list
```
```{R}
get2<- listExample["學期"]
str(get2)
get2 # listExample 只留下 學期元素，是個只有一個元素的list
```

```{r}
numVector <- c(2,3,6,-1,4,2,6)
select1 <- numVector[c(1,4)]; select1
select2 <- select1[[1]]; select2

# 相當於
numVector[c(1,4)][[1]] #兩步驟結合成一步驟

select1 <- numVector[c(T,T,F,T,F,F,T)]; select1
select2 <- select1[c(1,4)]; select2

# 相當於
numVector[c(T,T,F,T,F,F,T)][c(1,4)]
```
創造出只要“經濟學系”學生的邏輯向量，econOnly。
選出econOnly的names與gender。
在econOnly的gender下創造出只要“F”的邏輯向量, econFemaleOnly。
選出names中為“經濟學系”且“F”的姓名。
```{r}
majors <- c("經濟學系","經濟學系","社會學系","社工系","經濟學系")
names <- c("小英", "小美", "大雄","阿華", "阿尼")
gender <- c("F","F","M","F","M")

econ0nly<- list(majors[c(1,2,5)],names[c(1,2,5)],gender[c(1,2,5)])
econFemaleOnly<- gender[c(1,2)]
```

```{r}
str(listExample)
```
```{r}
listExample[[1]]
listExample[['student']]
listExample$student
```

```{r}
listExample[['學期']]    #拿出來
listExample$學期         #拿出來
```

```{r}
listExample['學期']     #只留下
```

```{r}
str(get1)
get1<- listExample[["學期"]]
get1[["108-1"]]->get1_layer1
get1_layer1[[1]]->get1_layer2
get1_layer2$teacher

listExample$學期$'108-1'[[1]][['teacher']]  #上面步驟合在一起
```

```{r}
get2<-listExample['學期'];get2
get2_layer1<-get2[[1]];get2_layer1
get2_layer2<-get2_layer1[['108-1']]
get2_layer3<-get2_layer2[[1]]
get2_layer3$teacher
```

```{r}
a <- c("1","b","TRUE")
a
a[[2]] <- "c" # 元素存在: 替換
a[[4]] <- "7" # 元素不存在： 增加
a[c(5,6)] <- c("J", "K")
a[7]<- 'johnson'
a<- c(a, 'mary')
```

```{r}
library(lubridate)
list1 <- 
  list(
    list(
      name="Jack",
      birthday=ymd("1998-03-21"),
      status=c(height=177, weight=80)
    )
  )

str(list1)
```

```{r}
# 更改日期
list1[[1]]$birthday <- ymd("1997-03-21")

# 新增資料
list1[[2]] <- list(
  name="Mary",
  birthday=ymd("1998-08-24")
)
list1[[2]][['status']]<-c(height=163,weight=45)
list1[[1]][[3]]$height<-176
str(list1)
```

```{r}
list1[[1]][["age"]] <- 21
list1[[2]]["age"] <- list(21)

# 改變「一個」時，使用[[ ]]比較不會錯。
str(list1)
```

```{r}
list1[[1]][c("bloodType","registered")] <- list("AB",TRUE)

str(list1)
```

```{r}
listExample <- 
  list(
    student="小明",
    `學期`=list(
      `108-1`=list(
        list(
          name="個體經濟學",
          teacher="Alice",
          grade=85
        )
      ),
      `108-2`=list(
        list(
          name="總體經濟學",
          teacher="Mark",
          grade=78
        )
      )
    )
  )
# 有多少位置可選：
length(listExample)
str(listExample)
```
```{r}

str(listExample)

# 108-1新增一科目成績
listExample$學期$`108-1`[[2]] <-
  list(name="產業經濟學")
str(listExample)

listExample$學期$`108-1`[[2]][c("teacher","grade")] <- 
  list(
    "Wen",
    88
    )
str(listExample)
```

```{r}
list1[[1]][-3]->list1[[1]]
str(list1)
```

```{r}
str(list1)
list1[[2]][c(1,2)] <- NULL    #不需回存
str(list1)
```

```{r}
a <- c(2, 3, 5)
b <- c(4,-1, 3)
```

```{r}
a+b
a-b
a*b
a/b
```

```{r}
a %% b #餘數
c(2%%3,4%%3)
a ** b #a的b次方
```

```{r}
sequenceNums <- c(11, 6, 8, 11, 12, 11, 3, 7, 10, 8)
print(sequenceNums)

sequenceNums %% 2 # 餘數為1則是奇數，0則是偶數
```

```{r}
# a+b 即等於
c(2+4, 3+(-1), 5+3)
# a**b 即等於
c(2**4, 3**(-1), 5**3)

5*c(1,3,4)+7
# 其實是
c(5)*c(1,3,4)+c(7)

## 對向量5，向量7進行recycle:
c(5,5,5)*c(1,3,4)+c(7,7,7)
## Recycle等長後才進行elementwise operation:
c(5*1+7, 5*3+7, 5*4+7)

# 狀況一: 堆疊一定倍數剛好一樣長
c(2,3)/c(-2,-13,10,22)
c(2,3,2,3)/c(-2,-13,10,22)

# 狀況二: 倍數堆疊一定會超過，只好截斷
c(2,3)/c(-2,-13,10)
c(2,3,2)/c(-2,-13,10)
```
```{r}
paste0(
  c("我叫"), c("小明","小美")
)
#上下相等
paste0(
  c("我叫","我叫"), c("小明","小美")
)
```


```{r}
example <- list(
  name=c("小明","小花","小新","美美"),
  height=c(175,166,170,160),
  weight=c(77,NA,60,43),
  birthday=lubridate::ymd(c("1998-03-11","1999-12-22","1995-08-22","2001-10-10")),
  hobby=c("美食 旅遊","旅遊 時尚","3C 美食","音樂 旅遊"),
  residence=c("Taipei","New Taipei","Taichung","Kaohsiung"),
  allowance=factor(c("0-1000","1001-2000","2000+","1001-2000")),
  bloodType=c("A","B","B","O")
)
```

```{r}
str(example[c("name","height")])
example$name[c(T, F, T, F)]

pick_above170 <- example$height >= 170
c(175,166,170,160)>=170
example$name[pick_above170]
```

```{r}
source("https://www.dropbox.com/s/qsrw069n94k61lj/transcript100to103_list.R?dl=1")
```

```{r}
# 各學屆2年級人數
table(transcript100to103$學屆)

# 只要成績大於85的
pick_above85 <-
  transcript100to103$`成績` > 85

# 各學屆2年級成績大於85年數
table(transcript100to103$學屆[pick_above85])

```

```{r}
print(example[c("name","birthday")])
#比較的雙方必須是同一個class 此例為date class
class(example$birthday) 
typeof(example$birthday)
pick_after98 <- example$birthday >= lubridate::ymd("1998-01-01")
example$name[pick_after98]
```

```{r}
source("https://www.dropbox.com/s/16h6ggua6qtydci/exchangeRate.R?dl=1")
```

```{r}
# 只要1998年1月（含）以後的
library(lubridate)
pick_after98_01 <-
  exchangeRate$期間 >= ymd("1998-01-01")
```

```{r}
exchangeRate_after98 <-
  list(
    `期間`=exchangeRate$`期間`[pick_after98_01],
    `幣別`=exchangeRate$`幣別`[pick_after98_01],
    `匯率`=exchangeRate$`匯率`[pick_after98_01]
  )
```

```{r}
print(example[c("name","allowance")])

pick_allowanceOver1000 <- example$allowance >= "1001-2000"
example$name[pick_allowanceOver1000]
```
factor資料可進一步分成可排序，與不可排序的，如：
* 可排序： 以年齡層區分的類別，以所得級距區分的類別等。
* 不排序： 性別，學系等。

factor的設定在不調整時內定為不可排序資料，如要改成可排序類別資料，以先前已處理好的example$allowance 為例：
```{r}
example$allowance <- 
  ordered(example$allowance)

```
或在設定為factor時即把levels排好，並ordered=T:
```{r}
example$allowance <-
  factor(example$allowance,
         levels=c("0-1000", "1001-2000", "2000+"),
         ordered = T # 設定為可排序factor)
```

```{r}
pick_allowanceOver1000 <- example$allowance >= "1001-2000"
example$name[pick_allowanceOver1000]
```

```{r}
jsonlite::fromJSON("https://www.dropbox.com/s/3uijub7xheib405/list_victimAges_female.json?dl=1", simplifyDataFrame = F) -> list_victimAges_female
```

```{r}
list_victimAges_female$數目 <-
  as.integer(list_victimAges_female$數目)
list_victimAges_female$年齡層 <- 
  as.factor(list_victimAges_female$年齡層)

```

```{r}
levels(list_victimAges_female$年齡層) -> levels_ages
print(levels_ages)
```

```{r}
levels_new <- c(levels_ages[c(12,13,1,8,2:7,9:11)])
levels(list_victimAges_female$年齡層) <- levels_new
```

```{r}
# 先將類別資料設定成可排序類別資料
list_victimAges_female$年齡層 <-
  ordered(list_victimAges_female$年齡層)
pick_above30 <- 
  list_victimAges_female$年齡層 >= "30_39歲"

```

```{r}
sum(list_victimAges_female$數目, na.rm=T)
sum(list_victimAges_female$數目[pick_above30], na.rm = T)
```

```{r}
print(example[c("name","bloodType")])

pick_bloodB <- example$bloodType == "B"
example$name[pick_bloodB]
```
==: 等於

!=: 不等於

==與!=可使用於字串


```{r}
sequenceNums <- c(11, 6, 8, 11, 12, 11, 3, 7, 10, 8)
pick_evens<- (sequenceNums %% 2)==0
sequenceNums[pick_evens]
```
%in%: 屬於

左邊元素「一一」檢視是不是屬於右邊元素集合。
```{r}
x <- c(1,5,8)
y <- c(5,8)

# x裡的元素值是不是屬於y集合
x %in% y
```

```{r}
print(example[c("name","residence")])

set_TaipeiMetro <- c("Taipei","New Taipei")
pick_fromTaipeiMetro <- example$residence %in% set_TaipeiMetro
example$name[pick_fromTaipeiMetro]
```

```{r}
str(transcript100to103)
set_lawbusiness<-c('法學院','商學院')
pick_lawbusiness<-transcript100to103$學院 %in% set_lawbusiness
pick_lawbusiness
```
unique() = 可取出重複出現物件之選項 例：法 商 社 文 法 法 文 商 會選出法商社文

在「要/不要」向量前加上!會成為否定句的「要/不要」向量，元素裡的TRUE會轉成FALSE, FALSE則轉成TRUE。
```{r}
pick_not_fromTaipeiMetro <- ! pick_fromTaipeiMetro
# 或
pick_not_fromTaipeiMetro <- !(example$residence %in% set_TaipeiMetro) # (..) 裡面會先運算完才做外面!的處理
```

```{r}
print(example[c("name","residence")])

example$name[pick_fromTaipeiMetro]
example$name[pick_not_fromTaipeiMetro]
```
is.na: 有缺失

is.{class/type name}: is.integer, is.character, is.factor … etc
```{r}
x2 <- c(1,NA,10)
y2 <- c(-1,NA,20)

x3 <- c(NA,"小花")
y3 <- c(NA,"小華")
```
前述的關係判斷遇到NA時，結果都會是NA——即無法判斷。要知道向量內各元素值是否NA，可使用is.na():
```{r}
is.na(x2)
```
example裡誰沒有體重資料
```{r}
print(example[c("name","weight")])

pick_na <- is.na(example$weight)
example$name[pick_na]
```
R還有一種特別的缺失資料NaN (即not a number)，出現在沒有定義的數學運算上，如：
```{r}
0/0
```

```{r}
list_victimAges_female$數目 <- as.integer(list_victimAges_female$數目)
pick_na <- is.na(list_victimAges_female$數目)
total_na <- sum(pick_na)
print(total_na)
```
4.4.5 字元偵測

stringr::str_detect()
example裡誰喜歡美食
```{r}
print(example[c("name","hobby")])

pick_loveFood <- stringr::str_detect(example$hobby,"美食")
example$name[pick_loveFood]
```
常有同學會有以下錯誤寫法:   == 字串內容一模一樣。
```{r}
pick_loveFood <- example$hobby == "美食"
```
str_detect 字串內容有關鍵字。
```{r}
example[["hobby2"]] <- c("美食", "時尚", "美食", "旅遊")

print(example[c("name", "hobby2")])
pick_loveFood2 <- example$hobby2 == "美食"
example$name[pick_loveFood2]
```
正確寫法
```{r}
print(example[c("name","hobby")])

pick_loveFood <- stringr::str_detect(example$hobby,"美食")
example$name[pick_loveFood]
```

```{r}
jsonlite::fromJSON("https://data.ntpc.gov.tw/od/data/api/EDC3AD26-8AE7-4916-A00B-BC6048D19BF8?$format=json") ->
  garbageRoutes
```

```{r}
#  1 用typeof()函數查詢電腦實質上如何看待garbageRoutes。
typeof(garbageRoutes)  
#  2 用class()函數查詢電腦把它能進行的操作運算歸屬於哪一類型。
class(garbageRoutes)
```

```{r}
# 由linename元素判斷垃圾車有幾條路線。
factor(garbageRoutes$linename) -> garbageRoutes$linename
levels(garbageRoutes$linename)
  
# 由linename創造： 可篩選出下午路線的「要/不要」向量pick_afternoonRoutes。
pick_afternoonRoutes <-
  stringr::str_detect(
    garbageRoutes$linename,
    "下午"
  )
garbageRoutes$linename[pick_afternoonRoutes]
```
4.4.5.1 閱讀函數說明
```{r}
?str_detect
```

```{r}
CDC_chatbox <- readr::read_csv("http://od.cdc.gov.tw/pr/CDC_chatbox.csv")
```

```{r}
pick_pneumonia<- stringr::str_detect(CDC_chatbox$Question,'肺炎')
CDC_chatbox$Question[pick_pneumonia]
```
length 函數所顯示的是向量中有幾個元素
```{r}
str(example)
pick_above170 <- example$height >= 170
pick_bloodB <- example$bloodType == "B"
pick_loveFood <- 
  stringr::str_detect(example$hobby,"美食")
pick_na <- is.na(example$weight)
pick_after98 <- 
  example$birthday >= lubridate::ymd("1998-01-01")
set_TaipeiMetro <- c("Taipei","New Taipei")
pick_fromTaipeiMetro <- 
  example$residence %in% set_TaipeiMetro
```

```{r}
str(example[c("name","hobby","bloodType")])

example$name[
    pick_loveFood & pick_bloodB
  ]
```

```{r}
example[c("name","birthday","residence")]

example$name[
  pick_after98 | !pick_fromTaipeiMetro
]
```

```{r}
example$name[
  pick_after98 & pick_fromTaipeiMetro & pick_bloodB
]
```

```{r}
install.packages("stringr")
library(stringr)
library(glue)
```
對character vector每個元素進行部份資訊粹取：

學號“410873002”，其中108是入學年，73是學系碼。 對100學年以後學生學系碼是固定在「第5、6位元」。
```{r}
str_sub("410873002", 5, 6)
```
lubridate對年只有西元年的概念。
要能想辦法把上面的“108”,“98”取出加上1911。
```{r}
lubridate::ymd(
  c("民國108年12月5日","民國98年10月5日")
)
```
lubridate裡的字串日期時間判斷採取的策略是「忽略非數字文字」只以「數字組合」（還允許各地習慣使用的文字，如March, Mar都是3月的意思）判斷時間，所以以下幾個都可以產生「西元」“2019-12-05”:
```{r}
lubridate::ymd(
  c(
    "民國2019年12月05日",
    "馬丁2019的12課05muydifícil",
    "助教2019Emily12解說05真棒",
    "2019R12課程05すごい",
    "R程式2019的12期中考05とても変態"
  )
)
```
4.6.1 Regular expression(regex)

請自RStudio Cheatsheets下載「Work with Strings Cheatsheet」pdf檔

一種廣義描述所要字串規律的表示法，分成兩部份：

target pattern: 指對取出字串的描述。如“108”,“98”是我們想取出的字串。我們可以說目標是，
「0-9的字元2-3個」: [:digit:]{2,3}或[0-9]{2,3}
target location description:
指target位置的情境描述。如“民國108年”,“民國98年”，我們可以說，
target前面是「民國」後面是「年」: (?<=民國)target_pattern(?=年)
合成regex：(?<=民國)[0-9]{2,3}(?=年)
```{r}
str_extract_all(
  c("民國108年12月5日","民國98年10月5日"),
  "(?<=民國)[0-9]{2,3}(?=年)"
) # 回傳list 

str_extract(
  c("民國108年12月5日","民國98年10月5日"),
  "(?<=民國)[0-9]{2,3}(?=年)"
) # 回傳vector 
```
4.6.2 組合alternate


用來製做一台吃角子老虎，它能夠包含你要的所有可能target出象。吃角子老虎由數條reel strip組成，每一條strip可以有以下幾種設計

固定字元/組：單寫一個字組或字元，表示那個strip固定不動只有一個出象，例如：2表示只有“2”一個出象，櫻桃只有“櫻桃”一個出象。
```{r}
heartSutra <- c("舍利子，色不異空，空不異色；色即是空，空即是色。")
install.packages("htmlwidgets")
str_view_all(heartSutra,"色") # 檢視
str_count(heartSutra,"色") # 計數
```
字「群」組合(..|..|..): strip上的出象會出現一組字時用，如“AB|ab”, 可以產生“AB”或“ab”兩種出象。

字群組合規則若很單純前後沒有接其他描述則( )可不寫
```{r}
studentIds <- c("410873029","410773005","410772035","410562123")
# 取出學號中的入學屆為107或108
str_view_all(studentIds,"(107|108)")

str_view_all(studentIds, "107|108") # 可不寫()

# 是否來自107或108學屆
str_detect(studentIds, "107|108")
```
字「元」組合[]: strip上的出象「均」是一個字「元」時用，如[af78]可以產生“a”,“f”,“7”,“8”四種字元出象。
幾種常見的字元模版：[0-9](或[:digit:])，[a-z](或[:lower:])，[A-Z](或[:upper:]),[0-9a-zA-Z](或[:alnum:])
```{R}
Ids <- c("A283743192","B829103720","A10920402","C291022384")

str_view_all(Ids, "[AC]")
str_detect(Ids, "[AC]") # 偵測 出現A、C

str_extract(Ids,"[A-Z]") # 取出 A-Z的字元
```
將設定好的reel strips依你要的順序排好就是你的regex slot machine, 它可以用來驗證字串裡頭是否出現來自你regex slot machine的某些組合。

```{R}
strip1 <- "[0-9]"
strip2 <- "(櫻桃|777|紅心)" # 字群組合strip因為等下放中間所以用()括起來
strip3 <- "[A-Z]"
myRegexSlotMachine <- paste0(strip1,strip2,strip3)
print(myRegexSlotMachine)
```

```{R}
claimA <- "我得到A檸檬99"
claimB <- "我的是7777Z"
claimC <- "我玩了兩次，一次是7蘋果H，另一次是5紅心J"
# 顯示吻合的出象
str_view(
  c(claimA,claimB,claimC),
  pattern=myRegexSlotMachine
)
# 是否有吻合的出象
str_detect(
  c(claimA,claimB,claimC),
  pattern=myRegexSlotMachine
)
```
以否定法定義的字「元」組合[^ ]: “[^趙錢孫李]”不能有趙錢孫李任何一個
```{R}
headline <- "資科系的謝陳官乃飛鳶書院三大名師，其中謝無雙的策略運算，陳大器的數理資科學，及官求敗的運算成本更是打通演算思維任督二脈的三大好課。書院目前有陳一、陳二、陳三四這三名學生。"

# 顯示所有符合規則的
str_view_all(headline, "謝陳官") # 固定字組
str_count(headline,"謝陳官")

str_view_all(headline, "[謝陳官]") # 有1個strip: 出象有3個可能字元 
str_count(headline, "[謝陳官]")

str_view_all(headline, "謝無雙|官求敗") # 有1個strip，出象有2個字組 
str_count(headline, "謝無雙|官求敗")

str_view_all(headline, "陳[^官]") # 固定字元＋有1個strip： 出象為排官的字元
str_count(headline, "陳[^官]")
```
請使用str_extract函數粹取出每個地址的“xx號”包含“號”字。
```{R}
addresses <- c(
  '臺中市后里區公館里尾社路385號',
  '新竹市東區科學園路125號1樓'
  )

strip1<-strip2<-strip3<-'[0-9]'
strip4<-'號'
myRegexSlotMachine <- paste0(strip1,strip2,strip3,strip4)
print(myRegexSlotMachine)
str_extract(addresses,myRegexSlotMachine)

```
(..|..|...)或[...]只是一條reel strip, 前者是寬的（每個出象可以是多字元）後者是窄的（每個出象只是一個字元）。有時我們同樣的belt想連放很多條，可以在(..|..|...)或[...]後面加：

{n}: 放n條belt，n是數字。
+: 放1條或以上（多少不限）。
{n,m}: 放n到m條belt，n及m都是數字。
```{R}
addresses <- c(
  '臺中市后里區公館里尾社路385號',
  '新竹市東區科學園路125號1樓',
  '新竹市北區竹光路99號',
  '金門縣金城鎮賢庵里山前33號',
  '臺中市南屯區工業區二十四路23號1樓')

myRegexSlotMachine <- "[0-9]+號"
print(myRegexSlotMachine)
str_view_all(addresses,myRegexSlotMachine)
str_extract(addresses,myRegexSlotMachine)

str_view_all(addresses,"[0-9]+") # 樓號也會選到
```
4.6.4 頭尾定位 Anchors:

在開頭：^target_regex

在結尾：target_regex$
```{R}
phrase <- c("唧唧复唧唧")

# 目標是前面的唧唧
target_regex <- "唧唧"
pattern <- glue::glue("^{target_regex}")
print(pattern)
str_view(phrase, pattern) 
```
glue套件裡的glue函數會把字串中的{物值名稱}換成目前Environment裡該物件的值。在上面{target_regex}會被換成“唧唧”。
```{R}
# 目標是後面的唧唧
target_regex2 <- "唧唧"
pattern <- glue::glue("{target_regex2}$")
print(pattern)
str_view(phrase, pattern) 
```
4.6.5 前後鄰居描述Look around:

target後面是B：target_regex(?=B_regex)： target_pattern後面是年

target前面是A：(?<=A_regex)target_regex：target_pattern前面是民國

target前有A後有B：(?<=A_regex)target_regex(?=B_regex)

民國年月日存成date class：
```{R}
twDate <-  c("民國108年12月5日","民國98年10月5日")

library(stringr)
# 準備regex: 
## 取出：「前有」民國，「後有」年的「數字」「們」
## "(?<={A_regex}){target_regex}(?={B_regex})"

target_regex <- "[0-9]+"
A_regex <- "民國"
B_regex <- "年"

regex_pattern <- glue::glue(
  "(?<={A_regex}){target_regex}(?={B_regex})"
  )

print(regex_pattern)

## 如果同學已經很熟就可以直接寫
regex_pattern <-
  "(?<=民國)[0-9]+(?=年)"

# 取出民國年，計算西元年
year <- 
  str_extract(
    twDate,
    regex_pattern)
westernYear <- as.integer(year)+1911

# 替換民國xx年的xx成西元年數字
str_replace(
  twDate,
  regex_pattern,  # 要換掉的文字
  as.character(westernYear) # 要替換的內容
) -> twDate_reformat
print(twDate_reformat)


lubridate::ymd(twDate_reformat)
```

```{R}
kangqi<-'康熙23年5月6日'
regex_pattern<- "(?<=康熙)[0-9]+(?=年)"
kangqi2<-str_extract(kangqi
,regex_pattern<- "(?<=康熙)[0-9]+(?=年)"

)
qiyuan<- as.integer(kangqi2)+1639

str_replace(kangqi,regex_pattern,as.character(qiyuan))
```

```{R}
addresses <- c(
  '臺中市后里區公館里尾社路385號',
  '新竹市東區科學園路125號1樓'
  )

regex_pattern<- "[0-9]+(?=號)"

str_extract(addresses,regex_pattern)
str_extract(addresses,"[0-9]+(?=號)")
```

```{R}
example.obj <- 'I am the man.I code with the javascript.'
str_extract(example.obj, 'javascript')
a <- c('I am the javascript man.', 'I code with the javascript.')
str_extract_all(a, 'javascript')
unlist(a)
```
4.7 On factor class

內定levels順序是根據電腦內字元排序（collating sequence）依辭典序列方式決定排序，很多時候沒有意義。
```{R}
char1 <- c("Wild","Apple","Donald","May","Avocada") 
factor1 <- factor(char1)
levels(factor1)
```

```{R}
library(stringr)
char2 <- c("蔡英文","習近平","Donald Trump","蔡頭") 
factor2 <- factor(char2)
levels(factor2)

sort(
  str_sub(char2,1,1)
)
sort(
  str_sub(char2,2,2)
)
```

```{R}
jsonlite::fromJSON("https://od.cdc.gov.tw/eic/Day_Confirmation_Age_County_Gender_19CoV.json") -> covid19
```

```{R}
# 不可排序類別：性別、縣市、是否境外移入
covid19$縣市 <- 
  factor(covid19$縣市)
covid19$性別 <-
  factor(covid19$性別)
covid19$是否為境外移入 <-
  factor(
    covid19$是否為境外移入
  )
```

```{R}
# 可排序類別資料：年齡層
covid19$年齡層 <-
  factor(
    covid19$年齡層,
    ordered=TRUE
  )
```

```{R}
levels(covid19$縣市)
levels(covid19$性別)
levels(covid19$是否為境外移入)
```

```{R}
covid19$年齡層
levels(covid19$年齡層)
```
4.7.1 levels重新排列

重新再定義factor一次

factor(目前的factor向量, levels=自訂排序)
levels放第二格時， levels= 可省略。

目前的類別向量的可不可排序性質依然會保留，不用特意去設ordered=T/F

使用函數時，若argument input的位置就是原help說明裡定義該argument位置時，「argument_name =」部份可以不寫。
```{R}
levels(covid19$性別)
covid19$性別 <- factor(covid19$性別, c("男","女"))
```
依與levels相關的其他數據排列：

covid19$縣市的levels依其人口由大排到小。如“新北市”人口最多，它就要排levels的第一個，依此類推。
演算思維：

```{R}

jsonlite::fromJSON(
  "https://www.dropbox.com/s/jckqryeh5zeat5w/regionPopulation.json?dl=1"
) -> population
unlist(population) -> population
print(population)
```
資料科學心法一：拿到新的資料先檢視「內容」、「class/type」
```{R}
print(population)
class(population) # 判斷出是named integer vector
names(population) # 元素名稱是台灣各縣市
```
2.留下levels中有的popluation元素
```{R}
levels(covid19$縣市) # 是名稱字串向量

# 由於population元素值有names，可以用`[名稱字串向量]`取出所要的
levels(covid19$縣市) -> levelsInData
population[levelsInData] -> population
```
3.將population由大排到小(sort(x, decreasing=T)可將x numeric vector由大排到小。)
```{R}
population <- sort(population, decreasing=T)
population
```
4.排完後population第一個元素值最大，它的名稱即是人口最多的縣市，第二元素值次大，它名稱是人口第二多縣市，依此類推。我們要的是population排完後的元素名稱。
```{R}
newLevels <- names(population)
newLevels
```
5.重設levels排序
```{R}
covid19$縣市 <-
  factor(
    covid19$縣市, levels=newLevels
  )

levels(covid19$縣市)
```

```{R}
table(covid19$縣市)
sort(table(covid19$縣市),decreasing = T)

```

```{R}
levels(covid19$年齡層)
```
取出levels中各年齡層的起始數字，存在startingAges
```{R}
level_names <- levels(covid19$年齡層)
startingAges <- stringr::str_extract(
  level_names,
  "^[0-9]+" # regex：開頭的一串數字
)
```
將startingAges變成named integer vector
```{R}
# 要numerical class排的才一定對
startingAges <- as.integer(startingAges)
names(startingAges) <- level_names
```
將startingAges從小排到大。
```{R}
sort(startingAges) -> startingAges
```
重設levels排序
```{R}
covid19$年齡層 <- 
  factor(
    covid19$年齡層, names(startingAges)
  )
levels(covid19$年齡層)
```
4.7.2 levels改名

levels(x) <- 
在R裡，若你看到函數f說明在Usage同時寫上f() <-的用法時，它表示此函數除了一般用來產生結果以外，也可以用來設定結果。

levels: 一般用來顯示類別

levels <- : 用來設定類別

其他常用到設定用法的還有names(),attr()等等
```{R}
factor1 <- factor(
  c("A","A","C","A","D","F","D","D")
)
factor1

levels(factor1) <- c("優","佳","尚可","普")

factor1
```
也可改levels其中幾個利用元素取代概念
由於factor內容的呈現是依循levels對照表走，所以levels內容一變，factor的內容呈現也變了。
```{R}
levels(factor1)[[1]] <- "Excellent"
levels(factor1)[c(3,4)] <- c("C","D")
factor1
```
4.7.3 levels整併

原本levels是台灣各縣市，你想改成北/中/南/東部四類。

原本年齡層levels是每5歲一個間距，你想改成10歲一個間距。

範例一：
```{R}
factor1 <- factor(c("新北市","台北市","台中市","彰化市","基隆市","苗栗縣","苗栗縣"))
factor1
```

```{R}
levels(factor1) <- c("中部","北部","北部","中部","北部","中部")
factor1
```
範例二：
```{R}
factor1 <- factor(c("0-4歲","5-9歲","10歲以上","0-4歲","5-9歲","5-9歲","10歲以上"))
factor1
```

```{R}
levels(factor1) <- c("0-9歲","10歲以上","0-9歲")
factor1
```
由covid19$縣市建立一個地區變數，值為北部、中部、南部、東部，其中：

北部：“宜蘭縣、基隆市、台/臺北市、新北市、桃園市、新竹市、新竹縣”

中部：“苗栗縣、台/臺中市、彰化縣、南投縣、雲林縣”

南部：“嘉義市、嘉義縣、台/臺南縣、台/臺南市、高雄市、屏東縣、澎湖縣”

東部：“花蓮縣、台東縣”
```{R}
covid19$地區 <- covid19$縣市

levels(covid19$地區)
currentLevels <- levels(covid19$地區)

# 整併
north_regex <- "宜蘭縣|基隆市|[台臺]北市|新北市|桃園市|新竹市|新竹縣"
middle_regex <- "苗栗縣|[台臺]中市|彰化縣|南投縣|雲林縣"
south_regex <-
  "嘉義市|嘉義縣|[台臺]南[縣市]|高雄市|屏東縣|澎湖縣"
east_regex <- "花蓮縣|台東縣"

currentLevels <- str_replace(currentLevels, 
            north_regex, "北部")
currentLevels <- str_replace(currentLevels, 
            middle_regex, "中部")
currentLevels <- str_replace(currentLevels, 
            south_regex, "南部")
newLevels <- str_replace(currentLevels, 
            east_regex, "東部")


levels(covid19$地區) <- newLevels
covid19$地區
```
將covid19$年齡層，由5歲間距成10歲間距，使改完後的levels為4 < 5-14 < 15-24 < …< 55-64 < 65+
```{R}
levels(covid19$年齡層)

# 創造10歲間距的所有可能
start <- seq(5, 55, by=10) # 由5到55，每個值差10的數值向量
end <- seq(14, 64, by=10)
middleLevels <- 
  rep(
    paste0(start,"-",end), 
    each=2) # 每個新間距要2個
newLevels <- c("4", middleLevels, "65+", "65+")

levels(covid19$年齡層) <- newLevels
covid19$年齡層
```
4.7.4 levels擴充

levels <-右邊值的部份包含原本的外，還有想新增的類別。
```{R}
factor2 <- 
  factor(c("好","好","普通","普通", "好"))
levels(factor2)
```
加一筆新資料“差”（之前沒有這類）
```{R}
factor2[[6]] <- "差"
factor2 # 元素6變NA
```
先擴大levels, 再加新資料
```{R}
factor2 <- 
  factor(c("好","好","普通","普通", "好"))
levels(factor2)

# 先擴大levels
levels(factor2) <- c(levels(factor2), "差")
levels(factor2)
factor2[[6]] <- "差"
factor2
```
factor無法用c(...)把兩個factor vector串接在一起：
```{R}
# non factor
char1 <- c("小明","小美")
char2 <- c("大雄","技安")
c(char1, char2)

# factor
factor1 <- factor(c("好", "壞", "壞"))
factor2 <- factor(c("壞", "好", "好"))
c(factor1, factor2)
```
因為The output type is determined from the highest type of the components in the hierarchy NULL < raw < logical < integer < double < complex < character < list < expression. factor是integer type所以會被當integer後才串接在一起。

正確接法：
```{R}
factor1[4:6] <- factor2
factor1
```
或使用套件forcats裡的fct_c函數
```{R}
forcats::fct_c(factor1, factor2)
```

```{R}
library(purrr)
example <- list(
  name=c("小明","小花","小新","美美"),
  height=c(175,166,170,160),
  weight=c(77,NA,60,43),
  birthday=lubridate::ymd(c("1998-03-11","1999-12-22","1995-08-22","2001-10-10")),
  hobby=c("美食 旅遊","旅遊 時尚","3C 美食","音樂 旅遊"),
  residence=c("Taipei","New Taipei","Taichung","Kaohsiung"),
  allowance=factor(c("0-1000","1001-2000","2000+","1001-2000")),
  bloodType=c("A","B","B","O")
)
```
我們有可能想要拿出其中屬於小新的資料：
```{R}
pick_小新 <- example$name == "小新"
data_selected <- 
  list(
    name=example$name[pick_小新],
    weight=example$weight[pick_小新],
    height=example$height[pick_小新],
    hobby=example$hobby[pick_小新],
    residence=example$residence[pick_小新],
    allowance=example$allowance[pick_小新],
    bloodType=example$bloodType[pick_小新]
  )
```


data_selected的產生，相當於進行

example[[1]][pick_小新],
example[[2]][pick_小新],
example[[3]][pick_小新],
example[[4]][pick_小新],
example[[5]][pick_小新],
example[[6]][pick_小新],
example[[7]][pick_小新]
再存放在list()裡。也就是我們想要：

對example底下的每個元素進行

[pick_小新]的動作

purrr底下的map()允許我們

使用.x來代表每個元素，即[[1]], [[2]], ..., [[7]]
所以

對每個元素進行[pick_小新]

可以寫成.x[pick_小新]。

由於.x[pick_小新]是個公式化的動作，在R，~代表要形成一個公式(formula)，所以

要寫成~ .x[pick_小新]

以一開始的例子為例：

對 example 底下的每個元素進行

.x[pick_小新] 的動作
```{R}
map(example, ~.x[pick_小新]) ->data_selected
```
範例：舞蹈表演

舞蹈表演資訊
```{R}
jsonlite::fromJSON("https://www.dropbox.com/s/6252gbdnv9owljm/dance.json?dl=1", simplifyDataFrame = F) -> dance
```
若想得到所有表演的名稱，我們得：

對 dance 每一個元素(.x表示)進行

.x$title的動作
```{R}
map(dance, ~.x$title) ->  list_titles

View(list_titles)
```
每個表演有時不止演出一場，每個表演的場次總數：
```{R}
# 記載第一個表演的所有場次訊息
dance[[1]]$showInfo
str(dance[[1]]$showInfo)
# 計算第一個表演有幾個場次
length(dance[[1]]$showInfo)
# 計算第二個表演有幾個場次
length(dance[[2]]$showInfo)
```
對 dance 每個元素進行

length(.x$showInfo)的動作
```{R}
map(dance, ~length(.x$showInfo))-> list_numberOfShows 
  
View(list_numberOfShows)
```
第4個表演有6個場次，想知道它們的日期時間：
```{R}
# 這個表演第1個場次的訊息
dance[[4]]$showInfo[[1]]$time
# 這個表演第2個場次的訊息
dance[[4]]$showInfo[[2]]$time
```
對 dance[[4]]$showInfo 的每個元素(.x)表示

進行 .x$time 動作
```{R}
map(dance[[4]]$showInfo, ~.x$time)
```
找出第8個表演的所有場次時間(time)和地點(location):
```{R}
str(dance[[8]])
map(dance[[8]]$showInfo, ~.x$location)
```

```{R}
jsonlite::fromJSON("https://data.ntpc.gov.tw/od/data/api/67BB3C2B-E7D1-43A7-B872-61B2F082E11B?$format=json", simplifyDataFrame = F) ->
  busRoutes
```
請抓出每條路線的Id(路線代碼)、providerId(業者代碼)、providerName(業者中文名稱)、nameZh(中文名稱)。
```{R}
map(busRoutes, ~.x$Id)
map(busRoutes, ~.x$providerId)
map(busRoutes, ~.x$providerName)
map(busRoutes, ~.x$nameZh)

```
第 5 章 Programming

5.1 Pipe

範例1
```{R}
threeHeigths <- c(Gary=178, John=182, Cam=175)
```
找出身高最高的人：

先排序由大到小，

接著取出第一個位置的人名

寫法一
```{R}
# 先排序由大到小，
sort(threeHeigths, decreasing=T) -> sorted_heights

# 把排好的人名取出
names(sorted_heights) -> sorted_persons

# 接著取出第一個位置的人名
sorted_persons[[1]] -> highestPerson
```
寫法二 有些同學會寫成
```{R}
names(sort(threeHeigths, decreasing = T))[[1]] -> highestPerson
```
寫法一可看出清楚的思路由左到右很符合人類寫作習慣，但會創出中間物件（sorted_heights），如果步驟一多會出現很多中間物件。 寫法二不會有中間物件，卻很不直覺
```{R}
library(magrittr)
```
可將寫法一變成串接無中間物件的方式：
```{R}
sort(threeHeigths, decreasing=T) %>% 
names(.) %>%
.[[1]] -> highestPerson
```
把 -> 中間物件 換成%>%

再把其他有用到中間物件的位置換成.

這樣概念就叫pipe operation.

範例2
```{R}
# 由cities創出每個元素對應的北部、東部、中部region factor
cities <- factor(c("台北","花蓮","台東","台中"))
levels(cities)
```

```{R}
region <- cities
library(stringr)
# 以下為一連串的pipe operation
levels(region) -> currentLevels
str_replace(currentLevels,"台北","北部") -> currentLevels1
str_replace(currentLevels1,"花蓮|台東","東部") -> currentLevels2
str_replace(currentLevels2,"台中","中部") -> regionLevels
regionLevels -> levels(region)
```

```{R}
levels(region) %>% 
  str_replace(.,"台北","北部") %>%
  str_replace(.,"花蓮|台東","東部") %>%
  str_replace(.,"台中","中部") ->
  levels(region)
```
5.1.4 .省略原則
若代表中間物件的.在函數的「第一位」則.*可省略不寫，連它後面的,也去掉。小心若不在第一位則不可做省略.動作。
```{R}
levels(region) %>%
  str_replace(.,"台北","北部") %>%
  str_replace(.,"花蓮|台東","東部") %>%
  str_replace(.,"台中","中部") ->
  levels(region)
```
可改成
```{R}
levels(region) %>% 
  str_replace("台北","北部") %>%
  str_replace("花蓮|台東","東部") %>%
  str_replace("台中","中部") -> 
  levels(region)
```
要小心%>%是將左邊output放到右邊函數，這裡的右邊函數指的是最外圍的函數：
```{R}
# 資料
population <- c(`cityA`=500,`cityB`=1500, `cityC`=399)
cities <- c("cityA","cityA","cityB","cityB","cityC")

# 分析步驟
names(sort(population)) -> setLevels
factor(cities, levels = setLevels) -> cities 
```
分析步驟你可能會寫
```{R}
population %>% 
  names(sort(.)) %>%
  factor(cities, levels=.) -> cities
```
會有誤源自於
```{R}
population %>% names(sort(.))
```
%>%是把population放到names()的input裡，而非sort()，但names()的input位置已被sort佔走。要改成
```{R}
population %>%
  sort() %>%
  names() %>%
  factor(cities, levels=.) -> cities
```
5.1.5 串接非單純函數程序

若遇到pipe 串接的下一段並不是單純的函數的話，可以用{}把此段內容括起來並把前一段output要放的位置換成.。

範例3
```{R}
library(purrr)
dataList <- list(
  num=c(2,97,22,15,7),
  chr=c("2","97","22","15","7")
)
```
找出dataList中元素class為numeric裡那些大於50的數字
```{R}
map(dataList, is.numeric) -> results
unlist(results) -> pick_numeric

dataList[pick_numeric] -> num_element
(num_element[[1]] > 50) -> pick_big
num_element[[1]][pick_big] -> bigNumber
```

```{R}
map(dataList, is.numeric) %>%
unlist(.) %>%

dataList[.] %>%
{(.[[1]] > 50)} %>%
num_element[[1]][.] -> bigNumber
```
5.1.5.0.0.1 範例4
```{R}
population %>% 
  names(sort(.)) %>%
  factor(cities, levels=.) -> cities
```

```{R}
population %>% 
  {names(sort(.))} %>%
  factor(cities, levels=.) -> cities
```
5.2 Function
用來執行一連串有固定SOP（流程）的動作

5.2.1 需求函數

qd=10−5p

會變動的步驟：

p=1.2, p=1.3, p=1.4
不會變動的步驟：

qd <- 10-5*p

```{R}
# p=1.2的需求量
p=1.2
qd <- 10-5*p # 小心是5*p, 不能寫5p
# p=1.3的需求量
p=1.3
qd <- 10-5*p
# p=1.4的需求量
p=1.4
qd <- 10-5*p
```
函數定義
```{R}
demand <- # 創造一個物件叫demand
  function(p){ # 定義這個物件為函數
    q_d <- 10-5*p # 小心是5*p, 不能寫5p
  }
```

```{R}
# p=1.2的需求量
demand(1.2) 
# p=1.3的需求量
demand(1.3)
# p=1.4的需求量
demand(1.4)
```
return
```{R}
demand_return <- 
  function(p){
    q_d <- 10-5*p
    return(q_d)
  }
# 印在螢幕，但Global Environment並不會有q_d
demand_return(1.2)
```
最近一步會使用到電腦記憶體的運算值會暫時記在：
```{R}
.Last.value
```

```{R}
# 要長久存在Global Environment要指定物件名稱（不要求與q_d同名）
demand_return(1.2) -> q_d1.2
```
當function有return時,
```{R}
demand_return(1.2) # 相當於
4
```

```{R}
demand_return(1.2) -> q_d1.2 # 相當於
4 -> q_d1.2
```
return(q_d)只會回傳q_d的「值」但不會回傳整個q_d物件在global environment裡。

實際上，{...}裡所創造的物件都只是「暫時的」且「不放在global environment」，函數運作完就刪除，所以global environment裡就算有同名物件，也不會因函數運作而被不小心更動。
```{R}
q_d <- 5
demand_return(p=1.2)

print(q_d)
```
5.2.2 今日天氣
住三峽的小雯問：“Silly，今天天氣如何？”

Silly需要知道什麼：

日期、地點
```{R}
dateInput <- today()
locationInput <- "新北市"
```
Silly找答案的策略：

政府開放資料平台：
```{R}
jsonlite::fromJSON("https://opendata.cwb.gov.tw/fileapi/v1/opendataapi/F-C0032-001?Authorization=rdec-key-123-45678-011121314&format=JSON") ->
  weather_next36hours
```
給定日期，地點找出預報資訊
```{R}
# 找出符合地點的天氣資訊：weatherAtLocation
(weather_next36hours$cwbopendata$dataset$location$locationName == locationInput) -> pick_location # 可挑出locationInput的「要/不要」向量

weather_next36hours$cwbopendata$dataset$location$weatherElement[pick_location][[1]] -> weatherAtLocation

# 在weatherAtLocation找出符合時間的天氣資訊

(weatherAtLocation$elementName=="MaxT") ->
  pick_MaxT
(weatherAtLocation$elementName=="MinT") ->
  pick_MinT
weatherAtLocation$time[pick_MaxT][[1]]$parameter$parameterName[[1]] -> maxT
weatherAtLocation$time[pick_MinT][[1]]$parameter$parameterName[[1]] -> minT

glue::glue("{locationInput} 氣溫，最高{maxT}度，最低{minT}度。")

str(weatherAtLocation)
```
打造Silly天氣預報機器人：
```{R}
askSilly_weather <- function(locationInput,dateInput){
  jsonlite::fromJSON("https://opendata.cwb.gov.tw/fileapi/v1/opendataapi/F-C0032-001?Authorization=rdec-key-123-45678-011121314&format=JSON") ->
  weather_next36hours
  
  (weather_next36hours$cwbopendata$dataset$location$locationName == locationInput) -> pick_location
  
  weather_next36hours$cwbopendata$dataset$location$weatherElement[pick_location][[1]] -> weatherAtLocation
  (weatherAtLocation$elementName=="MaxT") ->
    pick_MaxT
  (weatherAtLocation$elementName=="MinT") ->
    pick_MinT
  weatherAtLocation$time[pick_MaxT][[1]]$parameter$parameterName[[1]] -> maxT
  weatherAtLocation$time[pick_MinT][[1]]$parameter$parameterName[[1]] -> minT
  
  glue::glue("{locationInput} {dateInput} 氣溫，最高{maxT}度，最低{minT}度。")
}
```

```{R}
askSilly_weather("臺中市",today())
askSilly_weather("花蓮縣",today())
```
5.2.3 函數的組成
```{R}
class(demand_return)
```

```{r}
# 查詢函數formals arguments要求
formals(askSilly_weather)
```

```{r}
# 查詢函數主體
body(askSilly_weather)
```
函數可以存在list裡
```{r}
learning_topics <- 
  list(
    subject="函數",
    date=lubridate::ymd("2020-06-03"),
    functionsCreated=list(
      demand=demand_return # 等號右邊是呼叫demand_return的定義值，也就是function(...){...}值定義本身。
    )
  )
```

```{r}
learning_topics$functionsCreated$demand(1.2)
```
5.2.4 Environment
```{r}
typeof(demand_return)
```
Details
## [1] "closure"
function本身的運作並不能只靠它的定義值function(...){...}，還要有適當的環境（environment）條件才能生存。若物件的生存運作需要有適當的環境，表示電腦要存這個物件時還需要包含（enclose）它的（生存）環境一起存。這種儲存型態叫closure（閉包）。
```{r}
# 查詢函數執行所要求環境
environment(demand_return)
```

```{r}
# 若函數執行需要Global environment已存在某些物件，查詢需要哪些物件
codetools::findGlobals(demand_return)
```

```{r}
intercept <- 10
slope <- -5
myDemand <- function(p){
  q_d <- intercept + slope*p
  return(q_d)
}
```

```{r}
environment(demand_return)
environment(myDemand)
```

```{r}
codetools::findGlobals(demand_return)
codetools::findGlobals(myDemand) 

# myDemand對Global environment的要求多了intercept及slope
```

```{r}
# 移除global environment裡的intercept及slope
rm(intercept, slope)
```

```{r}
demand_return(1.2) # 維持正常運作
myDemand(1.2) # 無法運作
```
myDemand的運作需要global environment裡的intercept, slope物件。這表示

沒有intercept, slope在global environment裡它無法運作。

global environment裡的intercept, slope值若有改變，它的運作結果也會不同。(這種「要運作才去呼叫值」的特性叫Lazy evaluation，惰性求值)
```{r}
intercept <- 10
slope <- -5
myDemand(1.2)
```

```{r}
slope <- -1
myDemand(1.2)
```

```{r}
intercept <- 5
slope <- -1.2
myDemand(1.2)
```
5.2.5 預設值

函數lazy evaluation的特性，讓函數的運作：

具有隨時可改變運作狀態的彈性； 但

該工具若落在電腦知識不足的使用者手上會有誤動global environment而產生運作錯誤的危機。
```{r}
myDemand2 <- function(p, intercept=10, slope=-5){
  q_d <- intercept + slope*p
  return(q_d)
}
```

```{r}
environment(myDemand2)
findGlobals(myDemand2) # 不依靠global env裡的intercept/slope
```

```{r}
myDemand2(1.2)
myDemand2(1.2, slope=-1)
myDemand2(1.2, intercept=5, slope=-1.2)
```
預設值是「平常不需要動到的彈性arguments」，習慣上定義時最好放在arguments的最後面。
```{r}
kevin= function(x){y=x+3
return(y)
}
kevin(3)
```
5.3 Conditional Execution

5.3.1 if

用在「某個條件符合才執行」的狀況。
```{r}
if(condition){
  Body for TRUE
  }
```
condition: 它是個「是/否」問句。 (使用條件判斷來產生答案T/F，是個logical。)

判斷學號輸入正確與否

readline()在Rmd裡只有當它單獨執行時才能正常運作，因為readline是個即時互動（interactive）函數，Rmd不是個即時互動環境。
```{r}
# 先執行此行輸入學號
readline(prompt = "請輸入你的學號") -> studentId 

# 之後才執行以下程式
if(
  str_detect(studentId,'^[43](1[01][0-9]|9[0-9])[0-9]{5}$',negate=T) # condition: 是否輸入學號正確？
) {
  warning("你所輸入的學號不正確")
}
```
確認使用者有安裝需要套件
```{r}
if(!require(lubridate)){ # condition: 是否「沒安裝lubridate」？
  install.packages("lubridate")
}
lubridate::ymd_hms("2020-07-01 13:00:00 GMT")
```

```{r}
在4.6.5 前後鄰居描述Look around一節，我們可以把它形成一個
twDate <-  c("民國108年12月5日","民國98年10月5日")

library(stringr)
# 準備regex: 
## 取出：「前有」民國，「後有」年的「數字」「們」
## "(?<={A_regex}){target_regex}(?={B_regex})"

target_regex <- "[0-9]+"
A_regex <- "民國"
B_regex <- "年"

regex_pattern <- glue::glue(
  "(?<={A_regex}){target_regex}(?={B_regex})"
  )

print(regex_pattern)

## 如果同學已經很熟就可以直接寫
regex_pattern <-
  "(?<=民國)[0-9]+(?=年)"

# 取出民國年，計算西元年
year <- 
  str_extract(
    twDate,
    regex_pattern)
westernYear <- as.integer(year)+1911

# 替換民國xx年的xx成西元年數字
str_replace(
  twDate,
  regex_pattern,  # 要換掉的文字
  as.character(westernYear) # 要替換的內容
) -> twDate_reformat
print(twDate_reformat)


lubridate::ymd(twDate_reformat)
```
convert_TaiwanDate2WesternDate()函數：
```{r}
convert_TaiwanDate2WesternDate <- function(twDate){
  library(stringr)
  regex_pattern <-
    "(?<=民國)[0-9]+(?=年)"
  
  # 取出民國年，計算西元年
  year <- 
    str_extract(
      twDate,
      regex_pattern)
  westernYear <- as.integer(year)+1911
  
  # 替換民國xx年的xx成西元年數字
  str_replace(
    twDate,
    regex_pattern,  # 要換掉的文字
    as.character(westernYear) # 要替換的內容
  ) -> twDate_reformat
  
  lubridate::ymd(twDate_reformat) -> westernDate
  return(westernDate)
}

twDate <-  c("民國108年12月5日","民國98年10月5日")
convert_TaiwanDate2WesternDate(twDate)
```
這函數需要stringr及lubridate
```{r}
convert_TaiwanDate2WesternDate <- function(twDate){
  
  if(!require("stringr")){
    install.packages("stringr")
  }
  if(!require("lubridate")){
    install.packages("lubridate")
  }
  
  library(stringr)
  regex_pattern <-
    "(?<=民國)[0-9]+(?=年)"
  
  # 取出民國年，計算西元年
  year <- 
    str_extract(
      twDate,
      regex_pattern)
  westernYear <- as.integer(year)+1911
  
  # 替換民國xx年的xx成西元年數字
  str_replace(
    twDate,
    regex_pattern,  # 要換掉的文字
    as.character(westernYear) # 要替換的內容
  ) -> twDate_reformat
  
  lubridate::ymd(twDate_reformat) -> westernDate
  return(westernDate)
}
```
不重覆下載
```{r}
# 檢視步驟耗時elapse time
system.time(
  jsonlite::fromJSON("https://opendata.cwb.gov.tw/fileapi/v1/opendataapi/F-C0032-001?Authorization=rdec-key-123-45678-011121314&format=JSON") ->
  weather_next36hours
)
```

```{r}
if(!exists("weather_next36hours")){
    jsonlite::fromJSON("https://opendata.cwb.gov.tw/fileapi/v1/opendataapi/F-C0032-001?Authorization=rdec-key-123-45678-011121314&format=JSON") ->
    weather_next36hours
  SOAR::Store(weather_next36hours) # 存在.R_cache environment中
}
```

```{r}
SOAR::Store(weather_next36hours)會

創造一個.R_Cache環境並把weather_next36hours移到那裡放。
```

```{r}
askSilly_weather2 <- function(locationInput,dateInput){
  if(!exists("weather_next36hours")){
      jsonlite::fromJSON("https://opendata.cwb.gov.tw/fileapi/v1/opendataapi/F-C0032-001?Authorization=rdec-key-123-45678-011121314&format=JSON") ->
      weather_next36hours
    SOAR::Store(weather_next36hours) # 存在.R_cache environment中
  }  
  (weather_next36hours$cwbopendata$dataset$location$locationName == locationInput) -> pick_location
  
  weather_next36hours$cwbopendata$dataset$location$weatherElement[pick_location][[1]] -> weatherAtLocation
  (weatherAtLocation$elementName=="MaxT") ->
    pick_MaxT
  (weatherAtLocation$elementName=="MinT") ->
    pick_MinT
  weatherAtLocation$time[pick_MaxT][[1]]$parameter$parameterName[[1]] -> maxT
  weatherAtLocation$time[pick_MinT][[1]]$parameter$parameterName[[1]] -> minT
  
  glue::glue("{locationInput} {dateInput} 氣溫，最高{maxT}度，最低{minT}度。")
}
```

```{r}
system.time(
  askSilly_weather("新北市",today())
)
system.time(
  askSilly_weather("臺北市",today())
)

askSilly_weather("新北市",today())
askSilly_weather("臺北市",today())
```

```{r}
SOAR::Remove(weather_next36hours)
system.time(
  askSilly_weather2("新北市",today())
)
system.time(
  askSilly_weather2("臺北市",today())
)

askSilly_weather2("新北市",today())
askSilly_weather2("臺北市",today())
```
5.3.2 if else
```{r}
if(condition){
  body for TRUE condition
} else {
  body for FALSE condition
}
```
Mathematical function

f(n)={n/2       if nis even
      −(n+1)/2  if n is odd
```{r}
# n 為偶數
n <- 54
fvalue <- n/2

# n 為奇數
n <- 33
fvalue <- -(n+1)/2
```
Condition設計：n「是/否」為偶數？
```{r}
(n %% 2)==1 # 表示「奇數」; 或...

as.logical(n %% 2) # 只有0會變F，其他數值都是T
```
if…else…組合：
```{r}
n <- 54
if(as.logical(n %% 2)){
  fvalue <- -(n+1)/2
} else {
  fvalue <- n/2
}
```

```{r}
myFun <- function(n){
  if(as.logical(n %% 2)){
    fvalue <- -(n+1)/2
  } else {
    fvalue <- n/2
  }
  return(fvalue)
}

myFun(54)
myFun(33)
```
交卷提早時間
```{r}
jsonlite::fromJSON("https://www.dropbox.com/s/d14j5hp3i5ps657/examSubmissionTimes.json?dl=1") -> examSubmissionTime


head(examSubmissionTime$section)
head(examSubmissionTime$time)
```
Details
56節：deadline 下午3點

78節（即非56節）：deadline 下午5點

給定第i位學生，我們怎麼計算他/她的交卷提早時間？

沒有分歧情境

只有一個交卷時間：
```{r}
i<-1
student_i_section <- examSubmissionTime$section[[i]]
student_i_time <- examSubmissionTime$time[[i]]

deadline <- lubridate::ymd_hms("2020-05-27 15:00:00", tz="Asia/Taipei") # 

howEarly <- deadline - lubridate::ymd_hms(
  student_i_time, tz="Asia/Taipei") 
print(howEarly)
```
有分歧情境

有兩個交卷時間：
```{r}
student_i_section <- examSubmissionTime$section[[i]]
student_i_time <- examSubmissionTime$time[[i]]
```
===流程分歧點開始===
```{r}
deadline <- lubridate::ymd_hms("2020-05-27 15:00:00", tz="Asia/Taipei")
deadline <- lubridate::ymd_hms("2020-05-27 17:00:00", tz="Asia/Taipei")

```
===流程分歧點結束===
```{r}
howEarly <- deadline - lubridate::ymd_hms(student_i_time, tz="Asia/Taipei")
print(howEarly)
```
使用if…else控制情境分歧

Condition設計：
```{r}
i<-1
student_i_section <- examSubmissionTime$section[[i]]
student_i_time <- examSubmissionTime$time[[i]]

if(student_i_section=="56"){
  deadline <- lubridate::ymd_hms("2020-05-27 15:00:00", tz="Asia/Taipei")
} else {
  deadline <- lubridate::ymd_hms("2020-05-27 17:00:00", tz="Asia/Taipei")
}

howEarly <- deadline - lubridate::ymd_hms(student_i_time, tz="Asia/Taipei")
print(howEarly)
```
我們可以使用function＋map算出每位同學提早時間：
```{r}
compute_howEarly <- function(student_i_section, student_i_time){
  # student_i_section <- examSubmissionTime$section[[i]]
  # student_i_time <- examSubmissionTime$time[[i]]
  
  if(student_i_section=="56"){
    deadline <- lubridate::ymd_hms("2020-05-27 15:00:00", tz="Asia/Taipei")
  } else {
    deadline <- lubridate::ymd_hms("2020-05-27 17:00:00", tz="Asia/Taipei")
  }
  
  howEarly <- deadline - lubridate::ymd_hms(student_i_time, tz="Asia/Taipei")
  # print(howEarly)
  
  return(howEarly)
}

compute_howEarly(examSubmissionTime$section[[1]],examSubmissionTime$time[[1]])
compute_howEarly(examSubmissionTime$section[[2]],examSubmissionTime$time[[2]])
compute_howEarly(examSubmissionTime$section[[3]],examSubmissionTime$time[[3]])

studentSequence <- 1:length(examSubmissionTime$section)

map(studentSequence,
    ~compute_howEarly(
      examSubmissionTime$section[[.x]],
      examSubmissionTime$time[[.x]])
    ) -> list_howEarly

#78節和56節交卷提早時間比較

library(magrittr)
list_howEarly %>%
  unlist() -> examSubmissionTime$howEarly

pick_56 <- examSubmissionTime$section=="56"
mean(examSubmissionTime$howEarly[pick_56])
median(examSubmissionTime$howEarly[pick_56])

pick_78 <- examSubmissionTime$section=="78"
mean(examSubmissionTime$howEarly[pick_78])
median(examSubmissionTime$howEarly[pick_78])

```
5.3.3 if…else if… else

有時流程需要的分歧不只兩種情境，這時可以使用：
```{r}
if(condition A){
  body for A 
} else if(condition B){
  body for B
} else if(condition C){
  body for C
} else {
  body for none of the above
}
```
依需要可以不斷增加else if(...){....}的部份在中間。

else if 或 else前面一定要保有前一段情境的結束}。

成績等級：

>=90: 優 # condition A

80-89：良 # condition B

70-79：尚可 # condition C

70以下：待加強 # else
```{r}
readline("請輸入你的成績（整數）： ") -> grade # 單獨執行
```

```{r}
if(grade >=90){
  print("優")
} else if(grade>=80 & grade<=89){
  print("良")
} else if(grade>=70 & grade<=79){
  print("尚可")
} else {
  print("待加強")
}
```
各情境一定要互斥，即不可以有兩個情境有可能同時為TRUE，如果發生多個情境吻合會以第一個結果的body來執行。
```{r}
grade <- 80
if(grade >=90){
  print("優")
} else if(grade>=75 & grade<=89){
  print("良")
} else if(grade>=70 & grade<=85){
  print("尚可")
} else {
  print("待加強")
}

grade <- 80
if(grade >=90){
  print("優")
} else if(grade>=70 & grade<=85){
  print("尚可")
} else if(grade>=75 & grade<=89){
  print("良")
} else {
  print("待加強")
}
```
5.3.4 switch
另一種條件式執行常用在condition種類煩雜或要全部以「是/否」問句來切出所有互斥condition情境不容易設計時。

condition改成用文字描述，即conditionExpression。

不同conditionExpression與對應body內容改成使用一對對的:

"conditionExpression文字"={body 內容} 的name=value pair
```{r}
switch(實現的conditionExpression,
       "conditionExpression1"= {    },
       "conditionExpression2"= {    },
       :
       :
       "conditionExpressionN"= {    },
       {    })
```
Mathematical function

f(n)={n/2 if n is even−
    (n+1)/2if n is odd
 
 

```{r}
n<- 540

conditionExpression_outcome=
  ifelse(n %% 2==0, "even", "odd") 

switch(
  conditionExpression_outcome,
  "even"={fvalue <- n/2}, # 偶數
  "odd"=fvalue <- -(n+1)/2, # 奇數；只有一行指令可省略{}
  warning("n要整數喔")  
)

print(fvalue)
```
ifelse(test, yes, no)是超級好用/常用的函數：

test: class logical. 測試條件的結果

yes: 結果為T 時你希望的回傳值

no: 結果為F 時你希望的回傳值
```{r}
grades <- c(52, 77, 59, 88, 90)

ifelse(grades >= 60, "及格", "不及格")
```
在R裡{...}（大括號, brace）：

若只有一行指令則{}符號可省略。

依照上一個特性，function(...){....}的body若只有一行指令可省略{...}改寫成function(...) ..., 只是要小心body … 要接在function(...)之後不可換行。
```{r}
miniFun <- function(){
  lubridate::now()
}
miniFun()
```

```{r}
miniFun2 <- function() lubridate::now()
miniFun2()
```
若最後一個被執行的指令會產生print在螢幕的效果，則可以用{...}->或<-{...}將這print的值存出來。
```{r}
result <- 
  {
    x <- 2
    y <- 3
    x**y+15
  }
print(result)
```

```{r}
result2 <-
  {
    x <- 2
    y <- 3
    if(x< 3){
      warning("x值太小")
    } else {
      x**y+15
    }
  }
print(result2)
```
依照上一個特性，function(...){....}的body若最後一個「被執行」的指令是會印在螢幕的值，如該值要當回傳值可以不用return(...)就可以產生值回傳效果。
```{r}
myFun <- function(x,y){
  return(x**y+15)
}

# 等同於
myFun2 <- function(x,y){
  x**y+15
}

myFun(5,3) -> outcome
myFun2(5,3) -> outcome2
print(outcome)
print(outcome2)
```
cut：連續轉類別
可適當使用cut()函數將與「連續型」數值變數有關的condition轉成需要的字串表示，
```{r}
cut(x, c(a,b,c))
```
會將x分成(a,b], (b,c], 及NA 三大類。

x只要type是integer, double的資料都可使用，所以日期，時間都可以

(a,b]在數學上是a< . <=b，所以左側a值是「不包含」在裡面的

其中最小值可以是負無窮-Inf, 最大值可以是正無窮Inf。
```{r}
a <- c(1,2,3)
cut(a, c(1,2,3))
```
數字成績轉英文字母成績 成績等級：

>=90: A 同時螢幕出現“好棒棒” （89<…<=100）

80-89：B 同時螢幕出現“好棒” （79<…<=89）

70-79：C 同時螢幕出現“棒” （69<…<=79）

70以下：F 同時螢幕出現"-_-" (-1<…<=69)
```{r}
grade <- sample(1:100, 10, replace=T)

grade %>%
  cut(c(-1,69,79,89,100)) -> grade

levels(grade)

switch(
  as.character(grade[[1]]),
  "(-1,69]"={
    print("-_-")
    "F"},
  "(69,79]"={
    print("棒")
    "C"
    },
  "(79,89]"={
    print("好棒")
    "B"
    },
  "(89,100]"={
    print("好棒棒")
    "A"
    }
) -> letterGrade # 有回存時要螢幕印出的訊息一定要加print
```
管家機器人:

一家三口，

早上(06:00-09:00)： 媽媽讀《經濟學人》，爸爸讀《WSJ》，提醒小明“檢查書包東西都有帶嗎？”

晚上(17:00-19:00)： 媽媽準備全家晚餐點foodpanda，爸爸瀏覽tripadvisor(https://www.tripadvisor.com/)規劃週末全家旅行，提醒小明“作業寫好了嗎？”

晚上(23:30-次日淩晨1點)： 媽媽聆聽Spotify Jazz Classics(https://open.spotify.com/playlist/37i9dQZF1DXbITWG1ZJKYt)

其他時段：“機器人要休息，饒了我吧～～”
```{r}
nowtime <- glue::glue("{today()} 18:00:00") %>% ymd_hms(tz="Asia/Taipei")

library(lubridate)
library(glue)

# 建立可當cutpoints的一天時間點
cutpoints <-
  c(
    glue("{today()} 06:00:00"),
    glue("{today()} 09:00:00"),
    glue("{today()} 17:00:00"),
    glue("{today()} 19:00:00"),
    glue("{today()} 23:30:00"),
    glue("{today()+days(1)} 01:00:00")
  )
cutpoints %>%
  ymd_hms(tz="Asia/Taipei") -> cutpoints

## 將nowtime轉成它對應的時段是"morning", "evening", 或其他。
cut(nowtime, cutpoints) -> nowtime
levels(nowtime)[c(1,3,5)] <-
  c("morning","evening","jazz time")

## 使用switch決定要做什麼事
switch(
  as.character(nowtime),
  "morning"={
    print("要不要來閱讀點國際時事？")
    browseURL("https://economist.com")
  },
  "evening"={
    print("需不需要點餐呢？")
    browseURL("https://www.foodpanda.com.tw/")
  },
  "jazz time"={
    print("放鬆聽點Jazz。")
    browseURL("https://open.spotify.com/playlist/37i9dQZF1DXbITWG1ZJKYt")
  },
  {
    print("機器人要休息，饒了我吧～～")
  }
)
```

```{r}
whatNeedToDo_butler_mom <- function(nowtime=now()){
  library(lubridate)
  library(glue)

  cutpoints <-
    c(
      glue("{today()} 06:00:00"),
      glue("{today()} 09:00:00"),
      glue("{today()} 17:00:00"),
      glue("{today()} 19:00:00"),
      glue("{today()} 23:30:00"),
      glue("{today()+days(1)} 01:00:00")
    )
  cutpoints %>%
    ymd_hms(tz="Asia/Taipei") -> cutpoints
  
  cut(nowtime, cutpoints) -> nowtime
  levels(nowtime)[c(1,3,5)] <-
    c("morning","evening","jazz time")
  
  switch(
    as.character(nowtime),
    "morning"={
      print("要不要來閱讀點國際時事？")
      browseURL("https://economist.com")
    },
    "evening"={
      print("需不需要點餐呢？")
      browseURL("https://www.foodpanda.com.tw/")
    },
    "jazz time"={
      print("放鬆聽點Jazz。")
      browseURL("https://open.spotify.com/playlist/37i9dQZF1DXbITWG1ZJKYt")
    },
    {
      print("機器人要休息，饒了我吧～～")
    }
  )
}

ymd_hms(glue::glue("{today()} 08:00:00"),tz="Asia/Taipei") %>%
  whatNeedToDo_butler_mom()

ymd_hms(glue::glue("{today()} 14:00:00"),tz="Asia/Taipei") %>%
  whatNeedToDo_butler_mom()

ymd_hms(glue::glue("{today()} 18:00:00"),tz="Asia/Taipei") %>%
  whatNeedToDo_butler_mom()

ymd_hms(glue::glue("{today()+days(1)} 00:20:00"),tz="Asia/Taipei") %>%
  whatNeedToDo_butler_mom()
```
5.3.5 logical condition

由於if, if…else, if…if else…else, 都是用來決定要不要執行某個body，所以(condition) 必需要是「一個」T/F logical value。

比對答案
```{r}
myAnswer <- c(2,3,6)
correctAnswer <- c(2,3,5)

if(myAnswer == correctAnswer){ # 只取用第一個T/F
  print("你答對了")
}
```
R3.5以上版本可以設定
禁止length>1的logical condition.
```{r}
Sys.setenv("_R_CHECK_LENGTH_1_CONDITION_" = "true")
```
all, any
```{r}
myAnswer <- c(2,3,6)
correctAnswer <- c(2,3,5)

if(all(myAnswer == correctAnswer)){ # 要全TRUE
  print("你答對了")
}
```
&& ||

有時「資訊到這裡就夠判斷情境」會產生，這時可以用&&或｜｜

對答案：

class, 內容都要對
```{r}
myAnswer <- c(1,2,3)
correctAnswer <- factor(c(1,2,3))

if(is.factor(myAnswer) && all(myAnswer==correctAnswer)){
  print("答對了")
  10
} else {
  print("答錯了")
  0
}-> myGrade
myGrade
```

```{r}
if(is.factor(myAnswer) & all(myAnswer==correctAnswer)){
  print("答對了")
  10
} else {
  print("答錯了")
  0
}-> myGrade
myGrade
```
&會計算所有relations，&&只計算到第一個出現FALSE的relation.

&&用在「有一個錯就算錯」的情境。
|會計算所有relations，||只計算到第一個出現TRUE的relation.

||用在「有一個對就算對」的情境。
在進行condition execution時，使用&&, ||會比&, |更有運算效率。

condition最好少使用&或|因為兩邊relations若為logical向量長度>1，結果也會是個logical向量長度>1。


只要符合以下資格均可申請補助：

年齡>=65

家庭子孩數>3
```{r}
myAge <- 40
myChildrenNumber <- 5

if(myAge >=65 | myChildrenNumber >3){
  "符合申請資格"
} else {
  warning("不符合申請資格")
}

if(myAge >=65 ||  myChildrenNumber >3){
  "符合申請資格"
} else {
  warning("不符合申請資格")
}
```

```{r}
myAge <- 67
myChildrenNumber <- 5
if(myAge >=65 | myChildrenNumber >3){
  "符合申請資格"
} else {
  warning("不符合申請資格")
}

if(myAge >=65 ||  myChildrenNumber >3){
  "符合申請資格"
} else {
  warning("不符合申請資格")
}
```
5.3節主要在介紹「依情境執行不同body」的conditional execution，另外還有「依情境不同產生不同值」的conditional assignment。

一個logical relation:
```{r}
x <- c(2,5,10,-21,3,8)
ifelse(x %% 2==0, "even", "odd")
```
多個logical relations:
```{r}
y <- sample(40:100,20, replace=T)
dplyr::case_when(
  y < 60 ~ "F",
  60<=y & y < 70 ~"D",
  71<=y & y < 80 ~"C",
  80<=y & y < 90 ~"B",
  90<=y ~ "A"
)
y
```
5.3.6 斷句

關於R的斷句：

只要指令不完整就繼續往下一行找。

在if-else if-else的使用下，只要

} else 有同時出現
其他部份的斷句時機可自由決定。
```{r}
# if... else例子
flag=1

if(flag==1){
  print("flag 1.")
} else {
  print("else.")
}

stop("以下有誤")
if(flag==1){
  print("flag 1.")
} 
else {
  print("else.")
}
```

```{r}
# if else if else例子
flag=1

if(flag==1){
  print("flag 1.")
} else if(flag==2){
  print("flag 2.")
} else {
  print("else.")
}

if(flag==1){
  print("flag 1.")
} else 
if(flag==2){
  print("flag 2.")
} else 
{
  print("else.")
}

stop("以下有誤")
if(flag==1){
  print("flag 1.")
} else 
if(flag==2){
  print("flag 2.")
} 
else {
  print("else.")
}
```
一般推薦的斷句模式：
```{r}
if(){ # 條件情境描述
  
}
```

```{r}
if(){ # 條件情境描述
  
} else { # 條件情境描述
  
}
```

```{r}
if(){ # 條件情境描述
  
} else if(){ # 條件情境描述
  
} else { # 條件情境描述
  
}
```
5.4 Iteration

Rule of thumb: never copy and paste more than twice.

重覆兩次（包含第一個）okay. 三次…考慮一下迴圈吧！

但在設計迴圈時可以copy/paste 3 times來理解body如何設計

找出哪幾筆為“男”：
```{r}
sampleData <- list(
  list("男", 45), list("女", 32), list("男",50), list("男",33), list("女", 21)
)
```
男女只在sampleData每一個元素底下的第一個元素
```{r}
# 前三筆性別
sampleData[[1]][[1]]
sampleData[[2]][[1]]
sampleData[[3]][[1]]
```
5.4.1 Iteration components

我們在使用map時寫copy/paste程序3次，目的在確認：

Sequence: 即[[1]], [[2]], [[3]]出現的位置。

Body: 要重覆做的SOP，即~.x[[1]]。

而map最後會把每次Body的執行結果存在：

Output: 每次body執行完要存的形式，即map最後的list class output。


5.4.2 Two types of sequence

反覆要做的事
```{r}
sampleData[[1]][[1]]  
sampleData[[2]][[1]] 
sampleData[[3]][[1]] 
```
使用pipe寫法可以清楚分離sequence及body(SOP)。兩種sequence表示：
```{r}
# 串接寫法(I): external dispatch
sampleData[[1]] %>% {.[[1]]} 
sampleData[[2]] %>% {.[[1]]}
sampleData[[3]] %>% {.[[1]]}

map(sampleData, ~{.x[[1]]})

# 串接寫法(II): internal dispatch
1 %>% {sampleData[[.]][[1]]}  
2 %>% {sampleData[[.]][[1]]}  
3 %>% {sampleData[[.]][[1]]}

map(1:5, ~{sampleData[[.x]][[1]]})
# map在單維度遞迴時，.x也可以只寫.
map(1:5, ~{sampleData[[.]][[1]]})
```

```{r}
library(readr); library(stringr); library(purrr); library(magrittr); library(lubridate)
eggs <- rep("雞蛋x1", 8)

fryEgg <- function(egg){
  str_replace(egg, "雞蛋", "荷包蛋")
}

# external dispatch
eggs[[1]] %>% fryEgg(.)
eggs[[2]] %>% fryEgg(.)
eggs[[3]] %>% fryEgg(.)

map(eggs, ~fryEgg(.x)) -> friedEggs1

# internal dispatch
1 %>% {fryEgg(eggs[[.]])}
2 %>% {fryEgg(eggs[[.]])}
3 %>% {fryEgg(eggs[[.]])}

map(1:8, ~{fryEgg(eggs[[.]])}) -> friedEggs2
```
vectorized function
```{r}
grade <- c(45, 74, NA)

i<-2

grade_i <- grade[[i]]
if(!is.na(grade_i)){
  if(grade_i >= 60){
    "P"
  } else if(grade_i < 60 ) {
    "F"
  }
} else {
  "缺考"
}
```

```{r}
pass_or_fail <- function(grade_i){
  if(!is.na(grade_i)){
    if(grade_i >= 60){
      "P"
    } else if(grade_i < 60 ) {
      "F"
    }
  } else {
    "缺考"
  }
}

pass_or_fail(grade[[1]])
pass_or_fail(grade[[2]])
pass_or_fail(grade[[3]])

# 可否直接input整個grade vector
warning("不是vectorised function")
pass_or_fail(grade)
```
函數使用時若出現output value assigned動作時（即pass_fail_i <-），相當於執行了函數body pass_fail_i <-{...}，依switch小節的{...}處理原則：

若最後一個被執行的指令會產生print在螢幕的效果，則可以用{…}->或<-{…}將這print的值存出來。
此時可以省略return()。

可:

use map to wrap around non-vectorized function

```{r}
grade[[1]] %>% {pass_or_fail(.)}
grade[[2]] %>% {pass_or_fail(.)}
grade[[3]] %>% {pass_or_fail(.)}

map(grade, ~{pass_or_fail(.)}) # map to list

map_chr(grade, ~{pass_or_fail(.)}) # map to atom. vectof of class character

map_pass_fail <- function(grade){
  map_chr(grade, ~{pass_or_fail(.)})
}

```

```{r}
map_pass_fail(grade)
```
若你確信你map的list輸出每個元素只有一個值，且大家都相同class，則你可以依class的類形使用：

map_chr

map_lgl

map_dbl, map_int

省了unlist那一步。

常被拿來針對物件元素進行一一計算的函數建議可以將它改成vectorized function，以後在維護時比較容易。

Internal dispatching的優勢

當Body要同時對多個物件同時進行「元素一一處理」時，internal dispatch便顯得便利：

```{r}
eggs <- rep("雞蛋x1",10)
ham <- rep("火腿x1", 10)
toast <- rep("土司2片",10)

toast_withEggHam <- function(toast=NULL, egg=NULL, ham=NULL){
  if(is.null(toast) || !str_detect(toast, "土司")){stop("少了土司")}
  if(is.null(egg) || !str_detect(egg, "蛋")){stop("少了蛋")}
  if(is.null(ham) || !str_detect(ham, "火腿")){stop("少了火腿")}
  "火腿蛋三明治"
}

# 土司、火腿、蛋 第一份出列
1 %>% {toast_withEggHam(toast=toast[[.]], egg=eggs[[.]], ham=ham[[.]])}
# 土司、火腿、蛋 第二份出列
2 %>% {toast_withEggHam(toast=toast[[.]], egg=eggs[[.]], ham=ham[[.]])}
# 土司、火腿、蛋 第三份出列
3 %>% {toast_withEggHam(toast=toast[[.]], egg=eggs[[.]], ham=ham[[.]])}


map(1:10,
    ~toast_withEggHam(toast=toast[[.x]], egg=eggs[[.x]], ham=ham[[.x]]))
```
各系課程規劃

執行以下程序可以得到臺北大學100-107學年的開課資料courseStructure：
```{r}
jsonlite::fromJSON("https://www.dropbox.com/s/7myzzdnoor21hye/courseStructure2.json?dl=1") -> courseStructure
```
一位剛入學的經濟系新生想大致了解他系上對他未來四年的課程規劃是什麼？於是他想先看一下過去狀況。

以100學年入學之經濟系學生為對象，找出這群學生大一到大四的系上課程規劃是什麼？
```{r}
entranceYear <- 100
major <- "經濟系"
allGrades <- paste0(major, 1:4)
academicYears <- entranceYear+0:3

# 100學年 1年級
acadYear_i <- academicYears[[1]]
grade_i <- allGrades[[1]]
pick <-
  (courseStructure$學年==acadYear_i 
    &
    str_detect(courseStructure$應修系級, grade_i))
unique(courseStructure$科目名稱[pick])

# 101學年 2年級
acadYear_i <- academicYears[[2]]
grade_i <- allGrades[[2]]
pick <-
  (courseStructure$學年==acadYear_i 
    &
    str_detect(courseStructure$應修系級, grade_i))
unique(courseStructure$科目名稱[pick])

# 102學年 3年級
acadYear_i <- academicYears[[3]]
grade_i <- allGrades[[3]]
pick <-
  (courseStructure$學年==acadYear_i 
    &
    str_detect(courseStructure$應修系級, grade_i))
unique(courseStructure$科目名稱[pick])

# 103學年 4年級
acadYear_i <- academicYears[[4]]
grade_i <- allGrades[[4]]
pick <-
  (courseStructure$學年==acadYear_i 
    &
    str_detect(courseStructure$應修系級, grade_i))
unique(courseStructure$科目名稱[pick])
```
100學年1年級-103學年4年級，有哪幾行是一模一樣的？
```{r}
pick <-
  (courseStructure$學年==acadYear_i 
    &
    str_detect(courseStructure$應修系級, grade_i))
unique(courseStructure$科目名稱[pick])
```
以上的SOP要能運作，哪些物件要存在執行環境？
courseStructure, acadYear_i, grade_i

將(A)(B)形成函數
```{r}
get_courses <- function(acadYear_i, grade_i, courseStructure){
  pick <-
  (courseStructure$學年==acadYear_i 
    &
    str_detect(courseStructure$應修系級, grade_i))
  
  return(
    unique(courseStructure$科目名稱[pick])
  )
}
```
重寫100學年1年級-103學年4年級
```{r}
# 100學年 1年級
acadYear_i <- academicYears[[1]]
grade_i <- allGrades[[1]]
get_courses(acadYear_i, grade_i, courseStructure)

# 101學年 2年級
acadYear_i <- academicYears[[2]]
grade_i <- allGrades[[2]]
get_courses(acadYear_i, grade_i, courseStructure)

# 102學年 3年級
acadYear_i <- academicYears[[3]]
grade_i <- allGrades[[3]]
get_courses(acadYear_i, grade_i, courseStructure)

# 103學年 4年級
acadYear_i <- academicYears[[4]]
grade_i <- allGrades[[4]]
get_courses(acadYear_i, grade_i, courseStructure)
```
濃縮
```{r}
# 100學年 1年級
get_courses(academicYears[[1]], allGrades[[1]], courseStructure)

# 101學年 2年級
get_courses(academicYears[[2]], allGrades[[2]], courseStructure)

# 102學年 3年級
get_courses(academicYears[[3]], allGrades[[3]], courseStructure)

# 103學年 4年級
get_courses(academicYears[[4]], allGrades[[4]], courseStructure)
```
使用pipe
```{r}
1 %>% 
  {get_courses(academicYears[[.]], allGrades[[.]], courseStructure)}
2 %>% 
  {get_courses(academicYears[[.]], allGrades[[.]], courseStructure)}
3 %>% 
  {get_courses(academicYears[[.]], allGrades[[.]], courseStructure)}
4 %>% 
  {get_courses(academicYears[[.]], allGrades[[.]], courseStructure)}
```
使用map
```{r}

  map(1:4, ~{get_courses(academicYears[[.]], allGrades[[.]], courseStructure)})
```
Iteration in functional: map

Sequence: 1:4

Body: {get_courses(academicYears[[.]], allGrades[[.]], courseStructure)}, 以formula（另一種function形式）包裝。

Output: list class, length=Sequence length。
```{r}
1:4 %>%
  map(~{
    get_courses(academicYears[[.]], 
                allGrades[[.]], 
                courseStructure)})
```
5.4.3 for loop
這裡"{…}" 均是需要視情況定義的部份

vector(mode, length):

mode: character class，代表container所要用來裝的值之type。

length: integer class，代表container要有幾個空位。
```{r}
output <- vector("{type}", length={len})
for(.x in {sequence}){
  {body}
}
```
map範例：

map iteration：
```{r}
### 前置作業
entranceYear <- 100
major <- "經濟系"
allGrades <- paste0(major, 1:4)
academicYears <- entranceYear+0:3

jsonlite::fromJSON("https://www.dropbox.com/s/7myzzdnoor21hye/courseStructure2.json?dl=1") -> courseStructure

get_courses <- function(acadYear_i, grade_i, courseStructure){
  pick <-
  (courseStructure$學年==acadYear_i 
    &
    str_detect(courseStructure$應修系級, grade_i))
  
  return(
    unique(courseStructure$科目名稱[pick])
  )
}
```

```{r}
# 前置作業，接map iteration
map(1:4, 
    ~{
      get_courses(academicYears[[.x]], 
              allGrades[[.x]], 
              courseStructure)})
```
for iteration：（請先跑前置作業）
```{r}
# 前置作業，接for iteration
output <- vector("list", length=4)
for(.x in 1:4){
  get_courses(academicYears[[.x]], 
                allGrades[[.x]], 
                courseStructure) -> output[[.x]]
}
```
若internal dispatching sequence的長度是對應到某個物件元素個數，如上面1:4是對應academicYears（亦對應allGrades），則1:4可用seq_along(academiYears)取代。



```{r}
eggs <- rep("雞蛋x1",10)
ham <- rep("火腿x1", 10)
toast <- rep("土司2片",10)

toast_withEggHam <- function(toast=NULL, egg=NULL, ham=NULL){
  if(is.null(toast) || !str_detect(toast, "土司")){stop("少了土司")}
  if(is.null(egg) || !str_detect(egg, "蛋")){stop("少了蛋")}
  if(is.null(ham) || !str_detect(ham, "火腿")){stop("少了火腿")}
  "火腿蛋三明治"
}
```
map approach:
```{r}
map(1:10,
    ~toast_withEggHam(toast=toast[[.x]], egg=eggs[[.x]], ham=ham[[.x]]))
```
for approach:
```{r}
output <- vector("character", 10)
for(.x in 1:10){
  toast_withEggHam(toast=toast[[.x]], egg=eggs[[.x]], ham=ham[[.x]]) -> output[[.x]]
}
```
累計型output

Summation
```{r}
a <- sample(1:100, 10, replace=T)
print(a)
```
Sequence: 1:10

body: 到目前sequence .x前已經加總的值+ a[[.x]]

output: .x到10最後算完的值。
```{r}
sum <- 0
for(.x in 1:10){
  sum <- sum+a[[.x]]
}

print(sum)
```
長度不定型output
每次抽一個介於0到100的數字（抽出放回）抽10次，但每次必需是3的倍數才留下來。

```{r}
output <- c()
for(.x in 1:10){
  new <- sample(0:100,1)
  if(new %% 3==0){
    output <- c(output, new)
  }
}

print(output)
```
next
有時.x對應元素要附合某些條件才要進行body裡某些處理，不然可「跳過」。
```{r}
list(
  list("student A", c(2,3,4,5)),
  list("student B", NA), # 沒交作業
  list("student C", factor(c(2,3,4,5))),
  list("student D", factor(c(2,3,5)))
) -> collectionHWs

correctAns <- factor(c(2,3,4,5))

output <- vector("integer",length(collectionHWs))
nameVector <- vector("character", length(collectionHWs))
for(.x in seq_along(collectionHWs)){
  nameVector[[.x]] <- collectionHWs[[.x]][[1]]
  studentAns <- collectionHWs[[.x]][[2]] 
  if(is.na(studentAns)){
    output[[.x]] <- 0
    next
  } 
  
  # 改題部份
  if(identical(studentAns, correctAns)){
    output[[.x]] <- 10
  } else if (class(studentAns)!=class(correctAns) && identical(as.character(studentAns),as.character(correctAns))) {
    output[[.x]] <- 5
  } else {
    output[[.x]] <- 0
  }
}
names(output) <- nameVector

print(output)
```
5.4.4 while loop
有時我們面臨sequence長度未知，如擲一銅板直到出現5次正面才停。
```{r}
sum <- 0
for(i in 1:10){
  newToss <- sample(c("正","反"), 1, replace=T)
  if(newToss == "正"){
    sum <- sum+1
  }
  print(glue::glue("已擲{i}次得到{sum}次正面"))
}
```
for loop用很長的sequence再加上條件式break：

break會完全終止迴圈，而之前學到的next是不執行其以下的body直接跳下一個sequence值。
```{r}
sum <- 0
for(i in 1:100){
  newToss <- sample(c("正","反"), 1, replace=T)
  if(newToss == "正"){
    sum <- sum+1
  }
  print(glue::glue("已擲{i}次得到{sum}次正面"))
  if(sum==5){
    break
  }
}
```
while會一直反覆執行body直到conditionCondition為FALSE:
```{r}
while(continueCondition){
  body
}
```

```{r}
sum <- 0
count <- 0 # 計數器
while(sum<5){
  count <- count+1 # 計數器+1
  newToss <- sample(c("正","反"), 1, replace=T)
  if(newToss == "正"){
    sum <- sum+1
  }
  print(glue::glue("已擲{count}次得到{sum}次正面"))
}
```
由於while並沒有迴圈執行次數上限，若沒設好結束條件程式會一直跑下去鎖死電腦。為避免此問題，一般我們會放計數器，並在條件裡放計數上限，如下方四個#註明位置：

```{r}
count <- 0 # 計數器開始值
max_count <- 500 # 計數上限
while(continueCondition && count <= max_count){ # 增加計數上限條件
  count <- count+1 # 計數器加1
  body
}
```
之前的（有限）迴圈也可以用while寫：
```{r}
set.seed(1000) # 控制sample抽出的數字sequence固定，通常進行方法比對用

output <- c()
for(.x in 1:10){
  new <- sample(0:100,1)
  if(new %% 3==0){
    output <- c(output, new)
  }
}

print(output)
```
```{r}
a <- sample(1:100, 10, replace=T)
print(a)

sum <- 0
for(.x in 1:10){ 
  sum <- sum+a[[.x]]
}

print(sum)
```

```{r}
count <- 0 # 計數器起始值
sum <- 0
while(count <= 10){ # 計數上限條件
  count <- count+1 # 計數器+1
  sum <- sum+a[[count]]
}

print(sum)
```

幾乎每一個iteration都可以用functional, for, while寫一次，but …

“…the real downside of for loops is that they’re very flexible: a loop conveys that you’re iterating, but not what should be done with the results. Just as it’s better to use while than repeat, and it’s better to use for than while (Section 5.3.2), it’s better to use a functional than for. Each functional is tailored for a specific task, so when you recognise the functional you immediately know why it’s being used.” – from Advanced R.

不過若沒有追求時間效率的需求，還是以符合直覺的寫法優先，日後維護也比較能進入狀況。